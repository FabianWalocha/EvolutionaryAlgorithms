devtools::install_github('IOHprofiler/IOHexperimenter@R')
library('IOHexperimenter')


genetic_algorithm <- function(IOHproblem){

  target_hit <- function(f, IOHproblem) return(any(f>=IOHproblem$fopt));
  
  decode <- function(P) return(P);  # no decode in this case so just return
  
  evaluate <- function(G, IOHproblem){
    evalcount =+ 1
    return(IOHproblem$obj_func(G));  # return the value of the objective function
  }

  select <- function(f, index){ 
    # make fitness positive and transform so we avoid large values
    f = f - min(f)+1.0001; # shift the values to the right to make it positive. we dont want 0 or 1 so plus a constant
    f = log(f);
    
    f = f/sum(f); # normalize to sum to 1
    f = cumsum(f); # to make sure we always pick a parents. the intervals between the cumulative values will still be proportionate to the fitness.
    winner = NA;
    while (is.na(winner)){
      selected_parent = which(f>runif(1))[1] # choose a random parent based on chances of fitness value
      if(!is.na(index)){ # if we have a parent to compare to
        if(index != selected_parent ){ # check if the selected parent is not the same
        winner = selected_parent 
        }
      }else{ # if there is not parent to compare to yet
        winner = selected_parent
      }
    }
    return (winner);
  }
      
      
    
    # 
    # sel_res = which(f>runif(1)); # select all parents where the upperbound of the cumsum is bigger than or rdm number
    # if(!is.na(index)){
    #   if(index == sel_res[1]){
    #     winner = sel_res[2]
    #   } else {
    #     winner = sel_res[1];
    #   }
    # } else{
    #   winner = sel_res[1];
    # }
    # 
    # if(is.na(winner)){ # our winner is NA if the first parents was our selected parents and there was to parent with a higher upperbound
    #   winner = sample(1:length(f), 1)
    # }
    
    
    
    # # What if values are negative -> push to positive!
    # f = f - min(f)+1.0001; # shift the values to the right to make it positive. we dont want 0 or 1 so plus a constant
    # # What if values are super big -> log transformationS
    # f = log(f);
    # 
    # old_idxs = 1:length(f); #get the old order or fitness
    # #new_idxs = order(f, decreasing=TRUE);
    # #old_idxs = old_idxs[new_idxs];
    # #f = f[new_idxs];
    # f = f/sum(f); # normalize to sum to 1
    # f = cumsum(f); #
    # sel_res = which(f>runif(1));
    # if(!is.na(index)){
    #   if(index == sel_res[1]){
    #     winner = sel_res[2]
    #   } else {
    #     winner = sel_res[1];
    #   }
    # } else{
    #   winner = sel_res[1];
    # }
    # if(is.na(winner)){
    #   winner = sample(1:length(f), 1)
    # }
    # return(winner);
  
  crossover <- function(p1, p2){
    # we want to randomize the child we 'keep' 
    if(sample(0:1,1)){
      help = p1;
      p1 = p2;
      p2 = help;
    }
    
    n = length(p1)
    crossoverpoint = sample(1:(n-1),1);
    return(c(p1[1:crossoverpoint],p2[(crossoverpoint+1):n])) # swap the tails of the parents at the crossover point
  }
  
  mutate <- function(p,pm){
    sapply(p, function(x){
      if(runif(1)<pm){ #mutate a bit with chance pm
        return(1-x); #flip the bit
      } else{
        return(x);
      }
    })
    
    return(p)
  }
  

  ###################################################### Check what IOHproblem$obj_func is
  
  
  mu = 10; #size of the parent population
  pc = .7; #crossover rate
  pm = .01; #mutation rate
  budget = 50000; # number of evaluation 
  n = IOHproblem$dimension; #the binary vector for the genotype has length n. 
  fopt = -Inf;
  
  IOHproblem$set_parameters(pm);
  
  xopt = matrix(data=NA, nrow=mu, ncol=1);
  
  P = matrix(data=NA, nrow=mu, ncol=n); # Genotype. A vector of binary variables
  G = matrix(data=NA, nrow=mu, ncol=n); # Phenotype. A vector of binary variables
  f = rep.int(NA,mu);
  
  print(IOHproblem$obj_func);
  
  # Fill up the G P and f matrices for initial parent population
  evalcount = 0;
  for(i in 1:mu){
    P[i,] = sample(0:1,n,replace=T); #Genotype is generated by creating a vector of length n with binary values
    G[i,] = decode(P[i,]); # Genotype is decoded to Phenotype
    f[i] = evaluate(G[i,], IOHproblem) # Phenotypes are evaluated to represent fitness
  }

  # Evolution loop
  Pnew = matrix(data=NA, nrow=mu, ncol=n); # Offspring/children population
  while(evalcount<budget && !target_hit(f, IOHproblem)){
    for(i in 1:mu){
      #select the first parent based on their fitness
      p1 = select(f, NA);
      if(runif(1) < pc) { # with chance of pc, do cross over
        p2 = select(f, p1); # select the other parent to perform cross over with
		    Pnew[i,] = matrix(data=crossover(P[p1,],P[p2,]),nrow=1); # update our children with the new crossover result 
      } else {
        Pnew[i,] = P[p1, ]; # if no cross over, the child is the same as the parent
      }
      Pnew[i,] = matrix(data=mutate(Pnew[i,], pm),nrow=1); #mutate the child
    }
    P = Pnew; #set our offspring population to be our new parent population
    
    # Decode and evaluate
    for(i in 1:mu){
      G[i,] = decode(P[i,]);
      f[i] = evaluate(G[i,], IOHproblem);
      # Do we have an offspring which has a better fitness than any other before?
      if(any(f>fopt)){
        fopt = max(f);
        xopt = P[order(f,decreasing = TRUE)[1],]
      }
    }
  }
}


benchmark_algorithm(user_alg=genetic_algorithm, instances=c(1),dimensions=c(100), functions=seq(23), data.dir='./data/', params.track = 'pm')
